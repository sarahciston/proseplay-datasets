{"mappings":"AEsCA;gBAiBc,EAAE,EAAE,WAAW;IAgB3B;;;;OAIG;IACH,IAAI,CAAC,IAAI,EAAE,YAAY,GAAG,gBAAgB,GAAG,WAAW,GAAG,SAAS;IAQpE;;;;OAIG;IACH,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,YAAY,GAAG,gBAAgB,GAAG,WAAW,GAAG,SAAS;IAK3E;;;;OAIG;IACH,KAAK,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS;IAuE7B;;;;OAIG;IACH,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS;IA6DpC;;OAEG;IACH,QAAQ,IAAI,IAAI;IAkBhB;;OAEG;IACH,MAAM,IAAI,IAAI;IAyCd;;OAEG;IACH,QAAQ,IAAI,IAAI;IAwBhB;;;OAGG;IACH,UAAU,IAAI,OAAO;IAIrB;;;OAGG;IACH,QAAQ,IAAI,MAAM;IAgBlB;;;;OAIG;IACH,WAAW,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,QAAQ,GAAG,IAAI;IAS9C;;OAEG;IACH,IAAI,OAAO,IAAI,MAAM,EAAE,EAAE,CAIxB;IAED;;OAEG;IACH,IAAI,cAAc,IAAI,MAAM,EAAE,CAE7B;IAED;;;;OAIG;IACH,WAAW,CAAC,WAAW,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,GAAG,IAAI;CAM5D","sources":["src/src/choice.ts","src/src/window.ts","src/src/proseplay.ts","src/proseplay.ts"],"sourcesContent":[null,null,null,"import \"./proseplay.less\";\n\nimport { Window } from \"./window\";\nimport { Choice } from \"./choice\";\n\ntype Token = {\n  strings: string[]\n  linkIndex?: number | null,\n  horizontal?: boolean,\n  functionNames?: string[]\n};\ntype TokenizedLine = Token[];\ntype TokenizedText = TokenizedLine[];\n\nconst lineTemplate = document.createElement(\"div\");\nlineTemplate.classList.add(\"proseplay-line\");\n\nconst samples = {\n  dickinson: `We talked with each other about each other\nThough neither of us spoke —\nWe were (too engrossed with|listening to) the Second’s Races\nAnd the Hoofs of the Clock —\nPausing in Front of our (Sentenced Faces|Foundering Faces)\n(Time’s Decision shook —|Time compassion Took)\nArks of Reprieve he offered to us —\nArarats — we took —`,\n  homophones: `in the (mist|missed) (see|sea)\n(prey|pray) in the (morning|mourning)\nfor (words|worlds) that (exit|exist)\nas (seep|sleep)`,\n  hypothetically: `(hypothetically|hello)[1-]\n(what if|i said)[1-]\n(we fell|and held)[1-]\n(in love|till death)[1-]`\n};\n\nlet EM: number;\n\nclass ProsePlay {\n  private el: HTMLElement;\n\n  private lines: {\n    el: HTMLElement,\n    tokens: (string | Window)[],\n    windows: Window[]\n  }[] = [];\n  private windows: Window[] = [];\n  private links: Window[][] = [];\n\n  private _isExpanded: boolean = false;\n\n  private functions: {\n    [name: string]: Function\n  } = {};\n\n  constructor(el: HTMLElement) {\n    this.el = el;\n    this.el.classList.add(\"proseplay\");\n    window.addEventListener(\"resize\", this.handleResize);\n\n    EM = parseInt(getComputedStyle(el).fontSize);\n  }\n\n  private static createInstance(): ProsePlay {\n    const container = document.createElement(\"div\");\n    container.classList.add(\"proseplay\");\n    document.body.appendChild(container);\n    const pp = new ProsePlay(container);\n    return pp;\n  }\n\n  /**\n   * Load a sample.\n   * @param name The name of the sample to load.\n   * @returns The ProsePlay instance with the parsed text.\n   */\n  load(name: \"homophones\" | \"hypothetically\" | \"dickinson\"): ProsePlay {\n    this.lines = [];\n    this.windows = [];\n    this.links = [];\n\n    return this.parse(samples[name]);\n  }\n\n  /**\n   * Create a ProsePlay instance and load a sample.\n   * @param name The name of the sample to load.\n   * @returns A ProsePlay instance with the parsed text.\n   */\n  static load(name: \"homophones\" | \"hypothetically\" | \"dickinson\"): ProsePlay {\n    const pp = ProsePlay.createInstance();\n    return pp.load(name);\n  }\n\n  /**\n   * Parse the given string.\n   * @param str The formatted string to parse.\n   * @returns The ProsePlay instance with the parsed text.\n   */\n  parse(str: string): ProsePlay {\n    this.lines = [];\n    this.windows = [];\n    this.links = [];\n\n    str = str.trim();\n    let textTokens: TokenizedText = [];\n    let lines = str.split(\"\\n\");\n    lines.forEach(line => {\n      const lineTokens: TokenizedLine = [];\n      let m = line.matchAll(new RegExp(\n        \"\\\\(\" + // open parentheses\n          \"(\" + // start capturing group\n            \"[^(|)]+\" + // first string\n            \"\\\\|\" + // pipe\n            \"([^(|)]+\\\\|?)+\" + // one or more strings, with optional pipe\n          \")\" + // end capturing group\n        \"\\\\)\" + // close parentheses\n        \"(\\\\[(\\\\d)*(-)?\\\\])?\" // link index\n        , \"g\"));\n      const stringsIndex = 1,\n        linkIndex = 4,\n        orientationIndex = 5;\n\n      let currIndex = 0;\n      for (const match of m) {\n        const index = match.index as number;\n        let isEscaped = line[index - 2] === \"\\\\\";\n\n        let prevToken: Token = {strings: []},\n          currentToken: Token = {strings: []};\n        if (isEscaped) {\n          prevToken.strings = [line.slice(currIndex, index - 1)];\n          currentToken.strings = [line.slice(index, index + match[0].length)];\n        } else {\n          prevToken.strings = [line.slice(currIndex, index)];\n          currentToken.strings = match[stringsIndex].split(\"|\");\n          currentToken.strings.forEach((str, i) => {\n            let [s, fnc] = str.split(\"->\");\n            if (fnc) {\n              if (!currentToken.functionNames) {\n                currentToken.functionNames = [];\n              }\n              currentToken.functionNames[i] = fnc;\n\n              currentToken.strings[i] = s;\n            }\n          });\n          if (match[linkIndex]) {\n            currentToken.linkIndex = parseInt(match[linkIndex]);\n          }\n          if (match[orientationIndex] && (match[orientationIndex] === \"|\" || match[orientationIndex] === \"-\")) {\n            currentToken.horizontal = match[orientationIndex] === \"-\";\n          }\n        }\n        lineTokens.push(prevToken);\n        lineTokens.push(currentToken);\n\n        currIndex = index + match[0].length;\n      }\n      if (currIndex < line.length) {\n        lineTokens.push({strings: [line.slice(currIndex)]});\n      }\n      textTokens.push(lineTokens);\n    });\n  \n    this.constructText(textTokens);\n\n    return this;\n  }\n\n  /**\n   * Create a new ProsePlay instance and parse the given string.\n   * @param str The formatted string to parse.\n   * @returns A ProsePlay instance with the parsed text.\n   */\n  static parse(str: string): ProsePlay {\n    const pp = ProsePlay.createInstance();\n    pp.parse(str);\n    return pp;\n  }\n  \n  private constructText(text: TokenizedText): void {\n    this.el.innerHTML = \"\";\n    text.forEach(line => {\n      const lineEl = lineTemplate.cloneNode(true) as HTMLElement;\n      this.el.appendChild(lineEl);\n      this.lines.push({\n        el: lineEl,\n        tokens: [],\n        windows: []\n      });\n\n      line.forEach(token => {\n        if (token.strings.length === 1) {\n          const span = document.createElement(\"span\");\n          span.classList.add(\"proseplay-plaintext\");\n          span.innerText = token.strings[0];\n          lineEl.append(span);\n          this.lines[this.lines.length - 1].tokens.push(token.strings[0]);\n        } else {\n          const window = new Window(lineEl);\n          if (token.linkIndex) {\n            if (!this.links[token.linkIndex]) {\n              this.links[token.linkIndex] = [];\n            }\n            this.links[token.linkIndex].push(window);\n          }\n          if (token.functionNames) {\n            window.setFunctionNames(token.functionNames);\n          }\n          for (const name in this.functions) {\n            window.setFunction(name, this.functions[name]);\n          }\n          if (token.horizontal) {\n            window.setHorizontal();\n          }\n          this.lines[this.lines.length - 1].tokens.push(window);\n          this.lines[this.lines.length - 1].windows.push(window);\n          this.windows.push(window);\n          token.strings.forEach(str => window.addChoice(new Choice(str)));\n          window.activateChoice(window.choices[0]);\n        }\n      });\n      if (line.length === 0) {\n        lineEl.innerHTML = \"&nbsp;\";\n      }\n    });\n\n    this.links.forEach((windows, i) => {\n      windows.forEach(window => {\n        const otherWindows = windows.filter(otherWindow => otherWindow !== window);\n        window.setLink(i, otherWindows);\n      });\n    });\n  }\n\n  /**\n   * Slide each window to a random choice. If windows are linked, they will move to the same choice index together.\n   */\n  generate(): void {\n    if (this._isExpanded) return;\n\n    let windowsDragged: Window[] = [];\n    this.windows.forEach(window => {\n      if (windowsDragged.includes(window)) return;\n      let choiceIndex = window.random();\n      windowsDragged.push(window);\n      if (window.linkIndex) {\n        this.links[window.linkIndex].forEach(otherWindow => {\n          if (windowsDragged.includes(otherWindow)) return;\n          otherWindow.random(choiceIndex);\n          windowsDragged.push(otherWindow);\n        });\n      }\n    });\n  }\n\n  /**\n   * Expand all windows to show all choices at once. When this is enabled, all other interactions are disabled until `collapse()` is called.\n   */\n  expand(): void {\n    this._isExpanded = true;\n    this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n\n    const em = parseFloat(getComputedStyle(this.el).fontSize);\n    \n    this.lines.forEach(line => {\n      let marginBottom = 0;\n\n      line.windows.forEach(window => {\n        let height = window.el.scrollHeight - window.listEl.offsetTop;\n        window.el.style.height = `${height}px`;\n        \n        let y = window.el.scrollHeight - (window.currentIndex + 1) * 1.25 * em - 0.06 * em;\n        window.el.style.top = `${y}px`;\n        window.el.style.marginTop = `${-y}px`;\n        marginBottom = Math.max(marginBottom, y);\n\n        window.listEl.style.top = \"0px\";\n\n        let maxWidth = 0;\n        window.choices.forEach((choice, i) => {\n          choice.el.style.opacity = \"1\";\n          if (!window.horizontal) {\n            maxWidth = Math.max(maxWidth, choice.el.offsetWidth);\n          } else {\n            if (i > 0) {\n              maxWidth += EM;\n            }\n            maxWidth += choice.el.offsetWidth;\n          }\n        });\n        window.el.style.width = `${maxWidth}px`;\n\n        window.isHoverable = false;\n      });\n\n      line.el.style.marginBottom = `${marginBottom}px`;\n    });\n  }\n\n  /**\n   * Collapse all windows.\n   */\n  collapse(): void {\n    this._isExpanded = false;\n    this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n\n    this.lines.forEach(line => {\n      line.el.style.removeProperty(\"margin-bottom\");\n\n      line.windows.forEach(window => {\n        window.el.style.removeProperty(\"height\");\n        window.el.style.removeProperty(\"top\");\n        window.el.style.removeProperty(\"margin-top\");\n        window.listEl.style.removeProperty(\"top\");\n        window.choices.forEach(choice => {\n          choice.el.style.removeProperty(\"opacity\");\n        });\n        window.listEl.style.removeProperty(\"width\");\n\n        window.isHoverable = true;\n\n        window.activateChoice();\n      });\n    });\n  }\n\n  /**\n   * Check if windows are expanded or collapsed.\n   * @returns A boolean representing whether windows are expanded (true) or collapsed (false).\n   */\n  isExpanded(): boolean {\n    return this._isExpanded;\n  }\n\n  /**\n   * Return the current text.\n   * @returns A string of the current text.\n   */\n  snapshot(): string {\n    let text = \"\";\n    this.lines.forEach(line => {\n      line.tokens.forEach(token => {\n        if (token instanceof Window) {\n          text += token.choices[token.currentIndex].text;\n        } else {\n          text += token;\n        }\n      })\n      text += \"\\n\";\n    });\n\n    return text;\n  }\n\n  /**\n   * Set function to be called when certain choices are selected.\n   * @param name Name of function.\n   * @param fnc Function to be called.\n   */\n  setFunction(name: string, fnc: Function): void {\n    this.functions[name] = fnc;\n    this.windows.forEach(window => window.setFunction(name, fnc));\n  }\n\n  private handleResize = (): void => {\n    this.windows.forEach(window => window.activateChoice());\n  }\n\n  /**\n   * Return a nested list of choices in each window.\n   */\n  get choices(): string[][] {\n    return this.windows.map(window => {\n      return window.choices.map(choice => choice.text);\n    });\n  }\n\n  /**\n   * Return a list of indexes to which each window is currently set.\n   */\n  get currentIndexes(): number[] {\n    return this.windows.map(window => window.currentIndex);\n  }\n\n  /**\n   * Slide a specified window to a specified choice.\n   * @param windowIndex The index of the window to slide.\n   * @param choiceIndex The index of the choice to slide to.\n   */\n  slideWindow(windowIndex: number, choiceIndex: number): void {\n    if (windowIndex > this.windows.length - 1) return;\n    const window = this.windows[windowIndex];\n    if (choiceIndex > window.choices.length - 1) return;\n    window.slideToChoice(choiceIndex);\n  }\n}\n\nexport { ProsePlay }"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}